import paddle
import paddle.nn as nn
import paddle.nn.functional as F
from functools import partial

class Identity(nn.Layer):
    """A placeholder identity operator that is argument-insensitive.
    """
    def __init__(self):
        super(Identity, self).__init__()

    def forward(self, x):
        """Return input"""
        return x

class DenseLayer(nn.Layer):
    def __init__(self, in_dim, out_dim, activation=F.relu, bias=True):
        super(DenseLayer, self).__init__()
        self.activation = activation
        weight_attr = paddle.ParamAttr(initializer=nn.initializer.Orthogonal(gain=1.0))
        if not bias:
            self.fc = nn.Linear(in_dim, out_dim, weight_attr=weight_attr, bias_attr=False)
        else:
            self.fc = nn.Linear(in_dim, out_dim, weight_attr=weight_attr)
    
    def forward(self, input_feat):
        return self.activation(self.fc(input_feat))

class HeteroGraphConv(nn.Layer):
    def __init__(self, mods, aggregate='sum'):
        super(HeteroGraphConv, self).__init__()
        self.mods = nn.LayerDict(mods)
        if isinstance(aggregate, str):
            self.agg_fn = get_aggregate_fn(aggregate)
        else:
            self.agg_fn = aggregate

    def forward(self, g, inputs, time, mod_args=None, mod_kwargs=None):
        """Forward computation
        Invoke the forward function with each module and aggregate their results.
        Parameters
        ----------
        g : HeterGraph
            Graph data.
        inputs : Tensor
            Input POI features.
        time : str
            Current time segment.
        mod_args : dict[str, tuple[any]], optional
            Extra positional arguments for the sub-modules.
        mod_kwargs : dict[str, dict[str, any]], optional
            Extra key-word arguments for the sub-modules.
        Returns
        -------
        Tensor
            Output representations for POIs.
        """
        if mod_args is None:
            mod_args = {}
        if mod_kwargs is None:
            mod_kwargs = {}
        outputs = []
        for etype in g.edge_types:
            if 'at_' + time not in etype:
                continue
            rel_graph = g[etype]
            if rel_graph.num_edges == 0:
                continue
            dstdata = self.mods[etype[:2]](
                rel_graph,
                inputs,
                *mod_args.get(etype, ()),
                **mod_kwargs.get(etype, {}))
            outputs.append(dstdata)
        rsts = self.agg_fn(outputs)
        return rsts

def _max_reduce_func(inputs, axis):
    return paddle.max(inputs, axis=axis)

def _min_reduce_func(inputs, axis):
    return paddle.min(inputs, axis=axis)

def _sum_reduce_func(inputs, axis):
    return paddle.sum(inputs, axis=axis)

def _mean_reduce_func(inputs, axis):
    return paddle.mean(inputs, axis=axis)

def _stack_agg_func(inputs): # pylint: disable=unused-argument
    if len(inputs) == 0:
        return None
    return paddle.stack(inputs, axis=1)

def _agg_func(inputs, fn): # pylint: disable=unused-argument
    if len(inputs) == 0:
        return None
    stacked = paddle.stack(inputs, axis=0)
    return fn(stacked, axis=0)

def get_aggregate_fn(agg):
    """Internal function to get the aggregation function for node data
    generated from different relations.
    Parameters
    ----------
    agg : str
        Method for aggregating node features generated by different relations.
        Allowed values are 'sum', 'max', 'min', 'mean', 'stack'.
    Returns
    -------
    callable
        Aggregator function that takes a list of tensors to aggregate
        and returns one aggregated tensor.
    """
    if agg == 'sum':
        fn = _sum_reduce_func
    elif agg == 'max':
        fn = _max_reduce_func
    elif agg == 'min':
        fn = _min_reduce_func
    elif agg == 'mean':
        fn = _mean_reduce_func
    elif agg == 'stack':
        fn = None  # will not be called
    else:
        print('Invalid cross type aggregator. Must be one of '
                       '"sum", "max", "min", "mean" or "stack". But got "%s"' % agg)
    if agg == 'stack':
        return _stack_agg_func
    else:
        return partial(_agg_func, fn=fn)
